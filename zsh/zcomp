#!/bin/sh

# Completions

# K3S
# [[ $commands[kubectl] ]] && source <(kubectl completion zsh)
# [[ $commands[k3s] ]] && source <(k3s completion zsh)

# [[ $commands[rustup] ]] && eval $(rustup completions zsh)
# [ -n "$NVM_DIR" ] && [ -s "$NVM_DIR/bash_completion" ] && . "$NVM_DIR/bash_completion"

# [ -f "$ZDOTDIR/completions/_croc" ] && PROG=croc _CLI_ZSH_AUTOCOMPLETE_HACK=1 source "$ZDOTDIR/completions/_croc"
# [[ $commands[aws] ]] && source "$DOTFILES"/zsh/completions/aws-completion.sh

# pipx
# [[ $commands[pipx] ]] && eval "$(register-python-argcomplete pipx)"

# ALL ansible
# if command -v ansible 1> /dev/null; then
#     eval $(register-python-argcomplete ansible)
#     eval $(register-python-argcomplete ansible-config)
#     eval $(register-python-argcomplete ansible-console)
#     eval $(register-python-argcomplete ansible-doc)
#     eval $(register-python-argcomplete ansible-galaxy)
#     eval $(register-python-argcomplete ansible-inventory)
#     eval $(register-python-argcomplete ansible-playbook)
#     eval $(register-python-argcomplete ansible-pull)
#     eval $(register-python-argcomplete ansible-vault)
# fi

# # zsh parameter completion for the dotnet CLI
# _dotnet_zsh_complete()
# {
#   local completions=("$(dotnet complete "$words")")
#   # If the completion list is empty, just continue with filename selection
#   if [ -z "$completions" ]
#   then
#     _arguments '*::arguments: _normal'
#     return
#   fi
#   # This is not a variable assigment, don't remove spaces!
#   _values = "${(ps:\n:)completions}"
# }
# compdef _dotnet_zsh_complete dotnet
